---
layout: Post
title: 链表实现
date: 2023-3-1
author: hyh
useHeaderImage: false
headerImage: https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202303020922371.jpeg
permalinkPattern: /post/:year/:month/:day/:slug/
tags:
  - 数据结构与算法
---
## 一、链表实现的代码技巧

### 技巧1：理解指针或引用的含义

指针或引用的含义都是**存储所指对象的内存地址**。

将某个变量赋值给指针，实际上就是将这个变量的地址赋值给地址，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。
`p->next = q;`这段代码表示$p$结点中的`next`指针存储了$q$结点的内存地址。

`p->next=p->next->next;`这段代码表示$p$结点中的`next`指针存储了$p$的下下一个结点的内存地址。

### 技巧2：警惕指针丢失和内存泄漏

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202303011920459.jpeg" alt="img" style="zoom: 50%;" />

**单链表的插入操作**：在结点$a$和相邻的结点$b$之间插入结点$x$，假设当前指针$p$指向结点$a$。

如果将代码实现如下：

```c
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；
```

这样`p->next`指针在完成第一步操作之后，已经不再指向结点$b$了，而是指向结点$x$。第2行代码相当于将$x$赋值给`x->next`，自己指向自己。这样整个链表也就断成了两半，从结点$b$往后的所有结点都无法访问到了。

对于C语言来说，内存管理是由程序员负责的，如果没有手动释放结点对应的内存空间，就会产生内存泄露。所以我们在插入结点时，一定要注意操作的顺序，要先将结点$x$的`next`指针指向结点$b$，再将结点$a$的`next`指针指向结点$x$，这样才不会丢失指针，导致内存泄漏。

同理，**删除链表结点时，也一定要记得手动释放内存空间**，否则也会出现内存泄漏的问题。对于`Java`这种虚拟机自动管理内存的编程语言，就不需要考虑这么多了。

### 技巧3：利用哨兵结点简化实现难度

单链表插入：如果我们在结点$p$后面插入一个新的结点，代码实现如下：

```c
new_node->next = p->next;
p->next = new_node;
```

但如果要向一个空链表中插入第一个结点，就不能使用之前的逻辑，需要进行特殊处理。其中$head$表示链表的头结点。代码实现如下：

```c
if(head == NULL)
{
	head = new_code;
}
```

单链表删除：如果要删除结点p的后继结点，代码实现如下：

```c
p->next = p->next->next;
```

但如果要删除链表中的最后一个结点，也需要进行特殊处理，代码实现如下：

```c
if (head->next == null) {
   head = null;
}
```

可以发现，==针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理==。这样代码实现起来就会很繁琐，不简洁，而且也容易考虑不全而出错。

所以利用哨兵结点可以简化实现难度。”哨兵”解决的是国家之间的边界问题。同理，这里说的哨兵结点也是解决“边界问题”的，不直接参与业务逻辑。

我们引入哨兵结点，在任何时候，不管链表是不是空，head指针都会指向这个哨兵结点。我们将这种带有哨兵结点的链表叫**带头链表**。反之，没有哨兵结点的链表就叫作**不带头链表**。

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202303020922371.jpeg" alt="img" style="zoom:50%;" />

哨兵结点时不存储数据的，因为哨兵结点一致存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑。

这种利用哨兵简化编程难度的技巧，在很多代码实现中都有用到，比如插入排序、归并排序、动态规划等。

### 技巧4：重点留意边界条件处理

软件开发中，代码在一些边界或者异常情况下，最容易产生Bug。实现代码一定要在编写的过程中以及编写完成之后，检查边界条件是否考虑全面，以及代码在边界条件下是否能正确运行。

检查链表代码是否正确的边界条件：

- 如果链表为空时,代码是否能正常工作？
- 如果链表只包含一个结点时，代码是否能正常工作？
- 如果链表只包含两个结点时，代码是否能正常工作？
- 代码逻辑在处理头结点和尾结点的时候，是否能正常工作？

不光光是写链表代码，在写任何代码时，千万不要只是实现业务正常情况下的功能就好了，一定要多想想，你的代码在运行的时候，可能会遇到哪些边界情况或者异常情况，来保证代码的健壮性。

### 技巧5：举例画图，辅助思考

举个例子，往单链表中插入一个数据，将各种情况举个例子，画出插入前和插入后的链表变化，如图所示：

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202303021125421.jpeg" alt="img" style="zoom:50%;" />

看图去写代码，辅助自己思考代码实现的逻辑，写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的bug。

### 技巧6：多写多练，没有捷径

- 单链表反转
- 链表中环的检测
- 两个有序链表合并
- 删除链表倒数第n个结点
- 求链表的中间结点
