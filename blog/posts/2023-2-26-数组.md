---
layout: Post
title: 数组
date: 2023-2-26
author: hyh
useHeaderImage: false
headerImage: https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202302281004941.jpeg
permalinkPattern: /post/:year/:month/:day/:slug/
tags:
  - 数据结构与算法
---
## 一、定义

数组(Array)是一种 ==**线性表**== 数据结构，它用一组 ==**连续的内存空间**==，来存储一组具有 ==**相同类型的数据**== 。

**关键词**

- **线性表（Linear List）**:零个或多个数据元素的有限序列，若数据元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。

​		**数组、链表、队列、栈**都是线性表结构。

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202211241352533.jpeg"   style="zoom: 50%;" />

​		与线性表相对立的概念是**非线性表**，比如**二叉树、堆、图**等，在非线性表中，数据之间不是简单的前后关系。

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202211241400068.jpeg" style="zoom:50%;" />

- **连续的内存空间和相同类型的数据**：由于这两个特点，数组具有了 ==**随机访问**== 的特性，而缺点就是让数组的**插入、删除元素**的操作变得低效，为了保证连续性，就需要做大量的数据搬移工作。

## 二、操作

### 1.访问元素

举例：定义一个长度为10的int类型的数组：`int[] a = new int[10]` ，计算机会给数组`a[10]`分配一块连续内存空间1000~1039，其中内存块的首地址为 `base_address = 1000`.

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202211241425196.jpeg" style="zoom:50%;" />

计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，会通过下面的寻址公式，计算出该元素存储的内存地址：

```c
a[i]_address = base_address + i * data_type_size;
```

其中`data_type_size`表示数组中每个元素的大小。例子中数组a存储的是int类型，所以`data_type_size`为4个字节。

::: warning 警告

~~错误表述：“链表适合插入、删除，时间复杂度 $O(1)$；数组适合查找，查找时间复杂度为 $O(1)$;”~~

纠正：数组适合查找操作，但时间复杂度并不是$O(1)$，即使是已经排过序的数组，使用二分查找，时间复杂度为$O(logn)$.

正确表述：“数组支持随机访问，根据下标随机访问的时间复杂度为O(1).”

:::

### 2.插入元素

假设数组的长度为$n$，现在需要将一个数据插入到数组中的第$k$个位置，为了将第$k$个位置腾出来给新数据，需要将第$k$ ~ $n$这部分的元素都依次向后移动一个位置。如果在数组的末尾移动元素，那就不需要移动数据，此时时间复杂度为$O(1)$.如果在数组的开头插入元素，那所有的数据都需要依次向后移动一位，所以最坏时间复杂度是$O(n)$.因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为：$(1+2+...+n)/ n = O(n)$.

如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法进行搬移；如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数据插入到第$k$个位置，为了避免大规模数据搬移，可以 **将第$k$位的数据搬移到数组元素的最后，把新的元素直接放入第$k$个位置。**

举例：如果数组$a[10]$中存储了如下5个元素：$a、b、c、d、e$。现将元素$x$插入第3个位置。只需将$c$放入至$a[5]$，将$a[2]$赋值为$x$即可。

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202211241541546.jpeg" style="zoom:50%;" />

利用这种处理技巧，在特定场景下，在第k个位置插入一个元素的时间复杂度就会降为$O(1)$.==**这个处理思想在快速排序中也会用到**==。

### 3.删除元素

与插入数据类似，如果删除数组末尾的数据，则最好情况时间复杂度为$O(1)$；如果删除开头的数据，则最坏情况时间复杂度为$O(n)$；平均情况时间复杂度为$O(n)$。

::: tip 建议

在某些场景下，并不一定非得追求数组中数据的连续性。如果将多次删除操作集中在一起执行，删除的效率会提高很多。这种思想也在==**JVM标记清除垃圾回收算法**==中体现：第一遍扫描先标记垃圾对象，第二遍扫描再清除垃圾对象。

:::

举例：如果数组$a[10]$中存储了如下8个元素：$a、b、c、d、e、f、g、h$。现在依次删除$a、b、c$三个元素。

<img src="https://hyh1370039199-1313349927.cos.ap-chengdu.myqcloud.com/img/202211241618364.jpeg" style="zoom:50%;" />

为了避免$d、e、f、g、h$这几个数据会被搬移三次，我们可以先记录已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们在再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。

> 数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。

## 三、进阶

### 1.警惕数组的访问越界问题

```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

::: danger 注意

函数中使用的局部变量存储在栈上，而栈这种数据结构是一种由高地址向低地址生长的结构。

==如果用来编译这段程序的编译器按照内存地址依次递减的方式给变量分配内存==，函数中的局部变量从高位地址到低位地址依次是：i，a[2]，a[1]，a[0]。那么这段代码的运行结果并非是打印三行“hello world”，而是无限打印“hello world”。

因为数组大小为3，a[0]，a[1]，a[2]，而我们的代码中for循环结束条件错写为了i <= 3而非i < 3,所以当i = 3时，数组a[3]访问越界。根据寻址公式，a[3]对应的地址就是i的地址，a[3]赋值为0，那么就相当于i = 0，就会导致代码无限循环。

::: 

由于C语言非常重视运行时的效率，数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误，而且debug的难度非常大！

很多计算机病毒正是利用到代码中的数组越界可以访问非法地址的漏洞来攻击系统，所以写代码时一定要警惕数组越界。

但并非所有的语言都像C语言一样，把数组越界检查的工作丢给程序员来做，像Java本身就会做越界检查，如果数组越界，就会抛出异常`java.lang.ArrayIndexOutOfBoundsException`。

### 2.容器能否完全替代数组

针对数组类型，很多语言都提供了容器类，例如`Java`中的`ArrayList`、`C++ STL`中的`vector`。以`Java`的`ArrayList`为例，其优势在于：①**它将很多数组操作的细节封装起来**；②**支持动态扩容**。

数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。

如果使用ArrayList，我们不需要关心底层的扩容逻辑，每次存储空间不够时，ArrayList会将空间自动扩容为1.5倍大小。但需要注意：扩容操作涉及内存申请和数据搬移，比较耗时。所以如果能事先确定需要存储的数据大小，最好在创建ArrayList时候事先指定数据大小。

例如要从数据库中取出10000条数据放入ArrayList，事先指定数据大小可以省掉很多次内存申请和数据搬移操作。

```java
ArrayList<User> users = new ArrayList(10000);
for (int i = 0; i < 10000; ++i) {
  users.add(xxx);
}
```

使用高级语言编程，并不是数组一定毫无用武之地。

- `Java ArrayList`无法存储基本类型，比如`int`,`long`,需要封装为`Integer`、`Long`类；而`Autoboxing`、`Unboxing`则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。

- 如果数组大小已知，并且对数据的操作非常简单，用不到ArrayList 提供的大部分方法，也可以直接使用数组。

- 当要表示多维数组时，用数组往往会更加直观。比如 `Object [][] array`；而用容器的话则需要这样定义：`ArrayList<ArrayList<object>> array`。
- 对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器，成为首选。

### 3.为什么数组要从0开始编号。而不是从1开始呢？

#### 原因1：效率优化

从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”。如果用 a 来表示数组的首地址，a[0]就是偏移为 0 的位置，也就是首地址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址的公式为：

```c
a[k]_address = base_address + k * type_size
```

而如果数组从1开始计数，则计算a[k]的内存地址的公式为：

```c
a[k]_address = base_address + (k - 1) * type_size
```

对比两个公式，可以发现从1开始计数的话，每次随机访问数组元素都多了一次减法运算，对于CPU来说，就是多了一次减法指令。

数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，**==效率的优化就要尽可能做到极致==**。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。

二维数组在内存分配时，并非二维的，也是连续存储空间，其内存寻址：对于$m*n$的数组，$a[i][j](i<m,j<n)$的地址为：

```c
address = base_address + ( i * n + j) * type_size
```

#### 原因2：历史原因

C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。
